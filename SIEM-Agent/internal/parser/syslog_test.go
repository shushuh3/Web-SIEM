package parser
package parser

import (
	"strings"
	"testing"
	"time"

	"github.com/Narotan/SIEM-Agent/internal/reader"
)

func TestSyslogParserMatch(t *testing.T) {
	p := NewSyslogParser()

	tests := []struct {
		source   string
		expected bool




























































































































































































































































































}	}		<-done	for i := 0; i < 10; i++ {	}		}(i)			done <- true			}				}					t.Errorf("goroutine %d: unexpected error: %v", id, err)				if err != nil {				_, err := p.Parse(rawEvent)				}					Data:      strings.Repeat("x", j) + " test message",					Timestamp: time.Now(),					Source:    "/var/log/syslog",				rawEvent := reader.RawEvent{			for j := 0; j < 100; j++ {		go func(id int) {	for i := 0; i < 10; i++ {	done := make(chan bool)	// Parser should be safe for concurrent use (stateless)	p := NewSyslogParser()func TestSyslogParserConcurrent(t *testing.T) {}	}		}			p.Match(event)			event := reader.RawEvent{Source: s}		for _, s := range sources {	for i := 0; i < b.N; i++ {	b.ResetTimer()	}		"/var/log/nginx/access.log",		"/var/log/auth.log",		"/var/log/syslog",	sources := []string{	p := NewSyslogParser()func BenchmarkSyslogParserMatch(b *testing.B) {}	}		p.Parse(rawEvent)	for i := 0; i < b.N; i++ {	b.ResetTimer()	}		Data:      "Jan 15 10:30:45 myhost sshd[12345]: Failed password for root from 192.168.1.100 port 22 ssh2",		Timestamp: time.Now(),		Source:    "/var/log/auth.log",	rawEvent := reader.RawEvent{	p := NewSyslogParser()func BenchmarkSyslogParserParse(b *testing.B) {}	}		t.Errorf("expected RawLog to be preserved")	if event.RawLog != originalData {	}		t.Fatalf("unexpected error: %v", err)	if err != nil {	event, err := p.Parse(rawEvent)	}		Data:      originalData,		Timestamp: time.Now(),		Source:    "/var/log/syslog",	rawEvent := reader.RawEvent{	originalData := "Jan 15 10:30:45 host sshd[123]: Test message"	p := NewSyslogParser()func TestSyslogParserRawLogPreserved(t *testing.T) {}	}		t.Errorf("expected command to contain raw data")	if event.Command != rawEvent.Data {	// Should still parse without error, using fallback	}		t.Fatalf("unexpected error: %v", err)	if err != nil {	event, err := p.Parse(rawEvent)	}		Data:      "This is not a standard syslog format message",		Timestamp: time.Now(),		Source:    "/var/log/syslog",	rawEvent := reader.RawEvent{	// Non-standard syslog format	p := NewSyslogParser()func TestSyslogParserNonStandardFormat(t *testing.T) {}	}		t.Errorf("expected source=auth, got %s", event.Source)	if event.Source != "auth" {	}		t.Fatalf("unexpected error: %v", err)	if err != nil {	event, err := p.Parse(rawEvent)	}		Data:      "Jan 15 10:30:45 host sshd[123]: some auth message",		Timestamp: time.Now(),		Source:    "/var/log/auth.log",	rawEvent := reader.RawEvent{	p := NewSyslogParser()func TestSyslogParserAuthLog(t *testing.T) {}	}		})			}				t.Errorf("expected user=%s, got %s", tt.expectedUser, event.User)			if event.User != tt.expectedUser {			}				t.Fatalf("unexpected error: %v", err)			if err != nil {			event, err := p.Parse(rawEvent)			}				Data:      tt.data,				Timestamp: time.Now(),				Source:    "/var/log/syslog",			rawEvent := reader.RawEvent{		t.Run(tt.name, func(t *testing.T) {	for _, tt := range tests {	}		},			"",			"Jan 15 10:30:45 host kernel[0]: some kernel message",			"no user",		{		},			"bob",			"Jan 15 10:30:45 host sshd[123]: session opened for bob by root",			"for user format",		{		},			"alice",			"Jan 15 10:30:45 host sshd[123]: message with user=alice in it",			"user= format",		{	}{		expectedUser string		data         string		name         string	tests := []struct {	p := NewSyslogParser()func TestSyslogParserUserExtraction(t *testing.T) {}	}		})			}				t.Errorf("expected severity=%s, got %s", tt.expectedSev, event.Severity)			if event.Severity != tt.expectedSev {			}				t.Errorf("expected event_type=%s, got %s", tt.expectedType, event.EventType)			if event.EventType != tt.expectedType {			}				t.Fatalf("unexpected error: %v", err)			if err != nil {			event, err := p.Parse(rawEvent)			}				Data:      tt.data,				Timestamp: time.Now(),				Source:    "/var/log/syslog",			rawEvent := reader.RawEvent{		t.Run(tt.name, func(t *testing.T) {	for _, tt := range tests {	}		},			"info",			"system_event",			"Jan 15 10:30:45 host kernel[0]: CPU0: Core temperature above threshold",			"generic system event",		{		},			"medium",			"sudo_command",			"Jan 15 10:30:45 host sudo[123]: alice : TTY=pts/0 ; PWD=/home/alice ; USER=root ; COMMAND=/bin/ls",			"sudo command",		{		},			"low",			"user_logout",			"Jan 15 10:30:45 host sshd[123]: pam_unix(sshd:session): session closed for user alice",			"session closed",		{		},			"medium",			"user_login",			"Jan 15 10:30:45 host sshd[123]: pam_unix(sshd:session): session opened for user alice",			"session opened",		{		},			"high",			"auth_failure",			"Jan 15 10:30:45 host sshd[123]: Invalid user admin from 192.168.1.1",			"invalid user",		{		},			"high",			"error",			"Jan 15 10:30:45 host sshd[123]: Failed password for root from 192.168.1.1",			"auth failure",		{	}{		expectedSev  string		expectedType string		data         string		name         string	tests := []struct {	p := NewSyslogParser()func TestSyslogParserEventTypes(t *testing.T) {}	}		t.Errorf("expected severity=medium, got %s", event.Severity)	if event.Severity != "medium" {	}		t.Errorf("expected event_type=user_login, got %s", event.EventType)	if event.EventType != "user_login" {	}		t.Errorf("expected process=sshd, got %s", event.Process)	if event.Process != "sshd" {	}		t.Fatalf("unexpected error: %v", err)	if err != nil {	event, err := p.Parse(rawEvent)	}		Data:      "Jan 15 10:30:45 myhost sshd[12345]: Accepted publickey for alice from 192.168.1.100",		Timestamp: time.Now(),		Source:    "/var/log/syslog",	rawEvent := reader.RawEvent{	p := NewSyslogParser()func TestSyslogParserParseBasic(t *testing.T) {}	}		})			}				t.Errorf("Match(%s) = %v, expected %v", tt.source, result, tt.expected)			if result != tt.expected {			result := p.Match(event)			event := reader.RawEvent{Source: tt.source}		t.Run(tt.source, func(t *testing.T) {	for _, tt := range tests {	}		{"auth.log", true},		{"syslog", true},		{"/var/log/apache/error.log", false},		{"/var/log/nginx/access.log", false},		{"/var/log/messages", true},		{"/var/log/auth.log", true},		{"/var/log/syslog", true},	}{